# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 35*N ) * (lambda / (lambda +101-35*N)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 35*N ) * (lambda / (lambda +101-35*N)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 45*N ) * (lambda / (lambda +101-45*N)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 45*N ) * (lambda / (lambda +101-45*N)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# your team id number
###
id <- 35                 ### Change to the correct id!
###
set.seed(id)
p <- id/100
# matrices G and H
G <- matrix(c(1, 1, 1, 0, 0, 0, 0,
1, 0, 0, 1, 1, 0, 0,
0, 1, 0, 1, 0, 1, 0,
1, 1, 0, 1, 0, 0, 1), nrow = 4, byrow = TRUE)
H <- t(matrix(c(1, 0, 1, 0, 1, 0, 1,
0, 1, 1, 0, 0, 1, 1,
0, 0, 0, 1, 1, 1, 1), nrow = 3, byrow = TRUE))
# cat("The matrix G is: \n")
#G
#cat("The matrix H is: \n")
#H
#cat("The product GH must be zero: \n")
#(G%*%H) %%2
# generate N messages
message_generator <- function(N) {
matrix(sample(c(0,1), 4*N, replace = TRUE), nrow = N)
}
messages <- message_generator(100)
codewords <- (messages %*% G) %% 2
#  errors <- ...
#  received <-
T <- 30.1
m <- 35 * 10^(-6)
n <- 5
M <- 136.907089 # gram / mol this is the mass of c137
Na <- 6 * 10^23
n_list <- c(5, 10, 50)
# we need consistent units so our T must be converted from years to seconds we will calculate everything in seconds
T <- 30.1 * 365 * 24 * 60 * 60
T # = 949233600
# $\lambda$, is log(2)/T
# we found T so we can now calculate lambda (we need it to find mean)
lambda_for_all <- log(2) / T
lambda_for_all # = 7.302177e-10
# Now we can find N (number of atoms) = m/M NA
N <- m/M * Na
N # = 1.533887e+17
mu <- N * lambda_for_all
mu # = 112007142
# we have poisson distribution so it is easy for us to find sigma (= lambda) but we also should not forget that we search it per element and we have n of elements (=lambda/times). and sd would be sqrt of that value. BUT first I still calculated for all x-s
var_for_all <- mu
#sd_for_all <- sqrt(var_for_all) # in other words it is for whole distribution but since they are independent than later on we can just devide it by n (sum of independent poisson rv = poisson rv with new parameter)
#sigma_for_all # = 1.460435e-10
#sd_for_all # = 1.208485e-05
K <- 1e3 # times that our experiment is going to be repeated 1000
sample_means <- colMeans(matrix(rpois(n*K, lambda = mu), nrow=n)) # functrion that calculates the mean value of each column in a matrix of df VERY QUICK
# rpois generates randm nums from poisson distribution first param - num of rvs second- mean and variance
mu <- mu
sigma <- sqrt(var_for_all/n)
xlims <- c(mu-3*sigma,mu+3*sigma)
Fs <- ecdf(sample_means)
plot(Fs,
xlim = xlims,
ylim = c(0,1),
col = "blue",
lwd = 2,
main = "Comparison of ecdf and cdf")
curve(pnorm(x, mean = mu, sd = sigma), col = "red", lwd = 2, add = TRUE)
max_diffs <- numeric(length(n_list))
n_list <- c(5, 10, 50)
for (i in 1:length(n_list)) {
n <- n_list[i]
sample_means <- colMeans(matrix(rpois(n * K, lambda = mu), nrow = n))
#Fs <- ecdf(sample_means)
x_points <- seq(xlims[1], xlims[2], length.out = 1000)
x_grid <- seq(min(sample_means), max(sample_means), length.out = 1000)
ecdf_vals <- Fs(x_grid)
cdf_vals  <- pnorm(x_grid, mean = mu, sd = sigma)
max_diffs[i] <- max(abs(ecdf_vals - cdf_vals))
}
print("Maximal Differences")
names(max_diffs) <- paste("n=", n_list)
print(max_diffs)
print("As n gets bigger we can sees that diff between cdf and ecdf gets smaller and smaller. which numerically confirms clt")
bound <- 8*10^8
# Markov's Inequality
# P(S n>= 8*10^8) <= E(Sn) / 8*10^8
# E(Sn) / 8*10^8 <= 1-0.95 = 0.05
# n * mu / 8*10^8 <= 0.05
# n <= (0.05 * 8*10^8) / mu
#print(bound)
#print(mu)
n_markov <- ((0.05 * bound) / mu)
cat("n <=", n_markov)
# CLT
# We want P(Sn >=  8*10^8) <= 0.05
#
# at first we can standardize it cause it has aproximately normal distribution (Sn - n*mu) / sqrt(n*mu) >= ( 8*10^8 - n*mu) / sqrt(n*mu)
# The 95th percentile for a standard Normal is z = 1.645
# So, we need: (8*10^8 - n*mu) / sqrt(n*mu) >= 1.645
# 8*10^8 - sqrt(n)^2*mu >= 1.645 * sqrt(n) * sqrt(mu)
# mu*sqrt(n)^2 + (1.645*sqrt(mu))*sqrt(n) -  8*10^8 <= 0
x <- (-( 1.645 * sqrt(mu)) + sqrt(( 1.645 * sqrt(mu))^2 - 4 * mu * (-bound))) / (2 * mu)
n_clt <- x^2
cat("CLT: n <=", n_clt)
bound <- 8e8
mu_per_sample <- mu
desirable_prob <- 0.95
chernoff_log_root <- function(n) {
lambda <- n * mu_per_sample # calculating parameter of  sum of poisson rv
log_prob <- -lambda + bound * (1 + log(lambda / bound))
return(log_prob - log(1 - desirable_prob))
}
library(stats)
result <- uniroot(chernoff_log_root, lower = 1, upper = 8e8/mu)
n_chernoff <- result$root
cat("Chernoff bound n_max =", n_chernoff, "\n")
K_large <- 10000
sample_sums <- rpois(K_large, lambda = floor(n_clt) * mu)
successes <- sum(sample_sums < 8*10^8)
empirical_prob <- successes / K_large
cat(" n =", n_clt, "with K =", K_large)
cat("  empirical probability of sum < 8*10^8 is:", empirical_prob, "\n")
print("The simulated probability is close to our target of 0.95, which confirms that our calculation for n using the CLT was correct")
nu1 <- 45
K <- 1e3
#n <- 5
n_list <- c(5, 10, 50)
for (n in n_list){
sample_means <- colMeans(matrix(rexp(n*K, rate = nu1), nrow=n))
cat("for n =", n, " mean of sample means = ", mean(sample_means))
}
exp_mean <- 1/nu1
exp_var <- 1 / nu1^2
exp_sd <- exp_mean
mu <- exp_mean
sigma <- exp_sd / sqrt(n)
#print(n)
xlims <- c(mu-3*sigma,mu+3*sigma)
Fs <- ecdf(sample_means)
plot(Fs,
xlim = xlims,
col = "blue",
lwd = 2,
main = "Comparison of ecdf and cdf")
curve(pnorm(x, mean = mu, sd = sigma), col = "red", lwd = 2, add = TRUE)
# now let's do it for 5, 10, 50 and find differences
n_list <- c(5, 10, 50)
max_diffs <- numeric(length(n_list))
for (i in seq_along(n_list)) {
n <- n_list[i]
mat <- matrix(rexp(n*K, rate = nu1), nrow = n, ncol = K)
sample_means <- colMeans(mat)
mu <- 1/nu1
sigma <- (1/nu1) / sqrt(n)
Fs <- ecdf(sample_means)
xlim <- c(mu - 4*sigma, mu + 4*sigma)
plot(Fs, xlim = xlim, col = "blue", lwd = 2,
xlab = "mean", ylab = "CDF")
curve(pnorm(x, mean = mu, sd = sigma), add = TRUE, col = "red", lwd = 2)
x_grid <- seq(min(sample_means), max(sample_means), length.out = 1000)
ecdf_vals <- Fs(x_grid)
cdf_vals  <- pnorm(x_grid, mean = mu, sd = sigma)
max_diffs[i] <- max(abs(ecdf_vals - cdf_vals))
cat("n =", n, " mu =", round(mu,4), " sigma =", round(sigma,4),
" max diff =", round(max_diffs[i],4), "\n")
}
#markov
nu1 <- 35 + 10
m <- 100
time_limit <- 60
desired_prob <- 0.95
# P(X <= 100) >= 0.95
# P(X >= 101) <= lambda/101 <= 0.05 ->
# -> lambda = 5,05
# and this is poisson distribution so we know our lambda and it is E(X) = nu1 * N *60 it is the radioctivity (nu1 * 60 sec) in N times
# nu1 * N *60 = 5.05
# we know nu1 = 45
# N = 5.05/45*60
lambda <- (1 - desired_prob) * (m + 1)
#N_markov <- 5.05 / (60 * 45)
print(lambda)
N_markov <- lambda / (time_limit * nu1)
print(N_markov)
#n_markov <- m / (3 * nu1)
#CLT
a <- 1
b <- 1.645
c <- -100
x_solution <- (-b + sqrt(b^2 - 4*a*c)) / (2*a)
lambda_clt <- x_solution^2
N_clt_final <- lambda_clt / (60 * nu1)
cat("Solving quadratic equation:\n")
cat("x^2 + 1.645*x - 100 = 0\n")
cat("x =", x_solution, "\n")
cat("lambda =", lambda_clt, "\n")
cat("N_max (CLT) =", N_clt_final, "\n")
cat("N_max (CLT, rounded down) =", floor(N_clt_final), "\n\n")
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 45*N ) * (lambda / (lambda +101-45*N)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 45*N ) * (lambda / (lambda +101-45*N)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 45*N ) * (45*N/(101)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 45*N ) * (45*N/(101)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 45*N ) * (45*N/(101)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
# your team id number
###
id <- 35                 ### Change to the correct id!
###
set.seed(id)
p <- id/100
# matrices G and H
G <- matrix(c(1, 1, 1, 0, 0, 0, 0,
1, 0, 0, 1, 1, 0, 0,
0, 1, 0, 1, 0, 1, 0,
1, 1, 0, 1, 0, 0, 1), nrow = 4, byrow = TRUE)
H <- t(matrix(c(1, 0, 1, 0, 1, 0, 1,
0, 1, 1, 0, 0, 1, 1,
0, 0, 0, 1, 1, 1, 1), nrow = 3, byrow = TRUE))
# cat("The matrix G is: \n")
#G
#cat("The matrix H is: \n")
#H
#cat("The product GH must be zero: \n")
#(G%*%H) %%2
# generate N messages
message_generator <- function(N) {
matrix(sample(c(0,1), 4*N, replace = TRUE), nrow = N)
}
messages <- message_generator(100)
codewords <- (messages %*% G) %% 2
#  errors <- ...
#  received <-
T <- 30.1
m <- 35 * 10^(-6)
n <- 5
M <- 136.907089 # gram / mol this is the mass of c137
Na <- 6 * 10^23
n_list <- c(5, 10, 50)
# we need consistent units so our T must be converted from years to seconds we will calculate everything in seconds
T <- 30.1 * 365 * 24 * 60 * 60
T # = 949233600
# $\lambda$, is log(2)/T
# we found T so we can now calculate lambda (we need it to find mean)
lambda_for_all <- log(2) / T
lambda_for_all # = 7.302177e-10
# Now we can find N (number of atoms) = m/M NA
N <- m/M * Na
N # = 1.533887e+17
mu <- N * lambda_for_all
mu # = 112007142
# we have poisson distribution so it is easy for us to find sigma (= lambda) but we also should not forget that we search it per element and we have n of elements (=lambda/times). and sd would be sqrt of that value. BUT first I still calculated for all x-s
var_for_all <- mu
#sd_for_all <- sqrt(var_for_all) # in other words it is for whole distribution but since they are independent than later on we can just devide it by n (sum of independent poisson rv = poisson rv with new parameter)
#sigma_for_all # = 1.460435e-10
#sd_for_all # = 1.208485e-05
K <- 1e3 # times that our experiment is going to be repeated 1000
sample_means <- colMeans(matrix(rpois(n*K, lambda = mu), nrow=n)) # functrion that calculates the mean value of each column in a matrix of df VERY QUICK
# rpois generates randm nums from poisson distribution first param - num of rvs second- mean and variance
mu <- mu
sigma <- sqrt(var_for_all/n)
xlims <- c(mu-3*sigma,mu+3*sigma)
Fs <- ecdf(sample_means)
plot(Fs,
xlim = xlims,
ylim = c(0,1),
col = "blue",
lwd = 2,
main = "Comparison of ecdf and cdf")
curve(pnorm(x, mean = mu, sd = sigma), col = "red", lwd = 2, add = TRUE)
max_diffs <- numeric(length(n_list))
n_list <- c(5, 10, 50)
for (i in 1:length(n_list)) {
n <- n_list[i]
sample_means <- colMeans(matrix(rpois(n * K, lambda = mu), nrow = n))
#Fs <- ecdf(sample_means)
x_points <- seq(xlims[1], xlims[2], length.out = 1000)
x_grid <- seq(min(sample_means), max(sample_means), length.out = 1000)
ecdf_vals <- Fs(x_grid)
cdf_vals  <- pnorm(x_grid, mean = mu, sd = sigma)
max_diffs[i] <- max(abs(ecdf_vals - cdf_vals))
}
print("Maximal Differences")
names(max_diffs) <- paste("n=", n_list)
print(max_diffs)
print("As n gets bigger we can sees that diff between cdf and ecdf gets smaller and smaller. which numerically confirms clt")
bound <- 8*10^8
# Markov's Inequality
# P(S n>= 8*10^8) <= E(Sn) / 8*10^8
# E(Sn) / 8*10^8 <= 1-0.95 = 0.05
# n * mu / 8*10^8 <= 0.05
# n <= (0.05 * 8*10^8) / mu
#print(bound)
#print(mu)
n_markov <- ((0.05 * bound) / mu)
cat("n <=", n_markov)
# CLT
# We want P(Sn >=  8*10^8) <= 0.05
#
# at first we can standardize it cause it has aproximately normal distribution (Sn - n*mu) / sqrt(n*mu) >= ( 8*10^8 - n*mu) / sqrt(n*mu)
# The 95th percentile for a standard Normal is z = 1.645
# So, we need: (8*10^8 - n*mu) / sqrt(n*mu) >= 1.645
# 8*10^8 - sqrt(n)^2*mu >= 1.645 * sqrt(n) * sqrt(mu)
# mu*sqrt(n)^2 + (1.645*sqrt(mu))*sqrt(n) -  8*10^8 <= 0
x <- (-( 1.645 * sqrt(mu)) + sqrt(( 1.645 * sqrt(mu))^2 - 4 * mu * (-bound))) / (2 * mu)
n_clt <- x^2
cat("CLT: n <=", n_clt)
bound <- 8e8
mu_per_sample <- mu
desirable_prob <- 0.95
chernoff_log_root <- function(n) {
lambda <- n * mu_per_sample # calculating parameter of  sum of poisson rv
log_prob <- -lambda + bound * (1 + log(lambda / bound))
return(log_prob - log(1 - desirable_prob))
}
library(stats)
result <- uniroot(chernoff_log_root, lower = 1, upper = 8e8/mu)
n_chernoff <- result$root
cat("Chernoff bound n_max =", n_chernoff, "\n")
K_large <- 10000
sample_sums <- rpois(K_large, lambda = floor(n_clt) * mu)
successes <- sum(sample_sums < 8*10^8)
empirical_prob <- successes / K_large
cat(" n =", n_clt, "with K =", K_large)
cat("  empirical probability of sum < 8*10^8 is:", empirical_prob, "\n")
print("The simulated probability is close to our target of 0.95, which confirms that our calculation for n using the CLT was correct")
nu1 <- 45
K <- 1e3
#n <- 5
n_list <- c(5, 10, 50)
for (n in n_list){
sample_means <- colMeans(matrix(rexp(n*K, rate = nu1), nrow=n))
cat("for n =", n, " mean of sample means = ", mean(sample_means))
}
exp_mean <- 1/nu1
exp_var <- 1 / nu1^2
exp_sd <- exp_mean
mu <- exp_mean
sigma <- exp_sd / sqrt(n)
#print(n)
xlims <- c(mu-3*sigma,mu+3*sigma)
Fs <- ecdf(sample_means)
plot(Fs,
xlim = xlims,
col = "blue",
lwd = 2,
main = "Comparison of ecdf and cdf")
curve(pnorm(x, mean = mu, sd = sigma), col = "red", lwd = 2, add = TRUE)
# now let's do it for 5, 10, 50 and find differences
n_list <- c(5, 10, 50)
max_diffs <- numeric(length(n_list))
for (i in seq_along(n_list)) {
n <- n_list[i]
mat <- matrix(rexp(n*K, rate = nu1), nrow = n, ncol = K)
sample_means <- colMeans(mat)
mu <- 1/nu1
sigma <- (1/nu1) / sqrt(n)
Fs <- ecdf(sample_means)
xlim <- c(mu - 4*sigma, mu + 4*sigma)
plot(Fs, xlim = xlim, col = "blue", lwd = 2,
xlab = "mean", ylab = "CDF")
curve(pnorm(x, mean = mu, sd = sigma), add = TRUE, col = "red", lwd = 2)
x_grid <- seq(min(sample_means), max(sample_means), length.out = 1000)
ecdf_vals <- Fs(x_grid)
cdf_vals  <- pnorm(x_grid, mean = mu, sd = sigma)
max_diffs[i] <- max(abs(ecdf_vals - cdf_vals))
cat("n =", n, " mu =", round(mu,4), " sigma =", round(sigma,4),
" max diff =", round(max_diffs[i],4), "\n")
}
#markov
nu1 <- 35 + 10
m <- 100
time_limit <- 60
desired_prob <- 0.95
# P(X <= 100) >= 0.95
# P(X >= 101) <= lambda/101 <= 0.05 ->
# -> lambda = 5,05
# and this is poisson distribution so we know our lambda and it is E(X) = nu1 * N *60 it is the radioctivity (nu1 * 60 sec) in N times
# nu1 * N *60 = 5.05
# we know nu1 = 45
# N = 5.05/45*60
lambda <- (1 - desired_prob) * (m + 1)
#N_markov <- 5.05 / (60 * 45)
print(lambda)
N_markov <- lambda / (time_limit * nu1)
print(N_markov)
#n_markov <- m / (3 * nu1)
#CLT
a <- 1
b <- 1.645
c <- -100
x_solution <- (-b + sqrt(b^2 - 4*a*c)) / (2*a)
lambda_clt <- x_solution^2
N_clt_final <- lambda_clt / (60 * nu1)
cat("Solving quadratic equation:\n")
cat("x^2 + 1.645*x - 100 = 0\n")
cat("x =", x_solution, "\n")
cat("lambda =", lambda_clt, "\n")
cat("N_max (CLT) =", N_clt_final, "\n")
cat("N_max (CLT, rounded down) =", floor(N_clt_final), "\n\n")
# Chernoff
# e^(−λ)(eλ/k)^k.<= 0.05
#-lambda + k + k*(ln lambda)-k*lnk <= ln(0.05)
nu1 <- 45
k <- 101
desired_prob <- 0.95
chernoff_log <- function(N) {
lambda <- nu1 * N   #for each rv
log_bound <- exp(101 - 45*N ) * (45*N/(101)^101)
log_bound - 0.05
}
N_chernoff <- uniroot(chernoff_log,  interval = c(1e-10, 101/35 - 1e-6))$root
git init
source("~/.active-rstudio-document", echo = TRUE)
